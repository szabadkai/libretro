Below is a technical spec tailored to your constraints:

- Lit + Vite
- Deployed as static assets on GitHub Pages
- No custom backend
- WebRTC P2P, data only in browsers
- Session survives as long as at least one peer is alive (plus local snapshots)

---

## 1. Architecture Overview

**Type:** Single Page Application (SPA)  
**Hosting:** GitHub Pages (static)  
**Frontend:**

- Vite (TS)
- Lit for Web Components
- Optional: Y.js + y-webrtc for CRDT + P2P sync (recommended for robustness)

**Networking:**

- WebRTC DataChannels for P2P sync
- Public signaling servers only for SDP/ICE exchange (no app data stored server-side)
    - e.g. y-webrtc default signaling servers (`wss://signaling.yjs.dev`)
    - If you don’t want Y.js, you’ll need some similar public signaling infra

**Persistence:**

- In-memory state (authoritative during session)
- Local persistence per browser via IndexedDB or localStorage (for quick rejoin / offline)
- No central persisted store; the “source of truth” is the cluster of connected peers

---

## 2. Core Concepts

- **Board ID:** UUID or short random slug in URL: `/board/:boardId`
- **Board Document:** Shared state representing columns + notes
- **Peer:** A browser tab connected to a specific `boardId`
- **Room:** The set of peers connected to the same `boardId` via WebRTC

Board exists as long as at least one peer is in the room. If all peers leave, the only copies are the per-browser local snapshots.

---

## 3. Tech Stack & Dependencies

### 3.1 Core

- `lit` (latest)
- `vite` (TypeScript template)
- `typescript`
- `uuid` (for board IDs & client IDs)

### 3.2 P2P Sync (recommended approach)

- `yjs` – CRDT
- `y-webrtc` – WebRTC provider (handles:
    - peer discovery inside a room
    - signaling via public WebSocket servers
    - WebRTC DataChannel creation & reconnection)

This offloads a lot of complex sync logic while still satisfying: data is only stored in the browser; signaling servers only transport metadata.

---

## 4. Data Model

Use TypeScript types for conceptual clarity. The live data is stored in a Y.js `Doc`.

### 4.1 Types (conceptual)

```ts
type ColumnId = "good" | "bad" | "start" | "stop";

interface Note {
    id: string;
    columnId: ColumnId;
    text: string;
    x: number;
    y: number;
    createdAt: number; // epoch ms
    updatedAt: number; // epoch ms
}

interface BoardMeta {
    id: string;
    name: string | null; // optional
    createdAt: number;
}
```

### 4.2 Y.js Document Structure

```ts
// Y.Doc structure
// doc.getMap<Y.Map | Y.Array | ...>("board")
board: {
    meta: Y.Map<BoardMeta>;
    notes: Y.Map<Note>; // key: noteId → Note
}
```

- `meta`:
    - `id`: boardId
    - `name`: optional board name
    - `createdAt`
- `notes`:
    - Map from `noteId` to `Note`

**Reasoning:**  
CRDT at field-level; concurrent updates across peers merge consistently. No home-grown op-log/version vectors needed.

---

## 5. P2P Sync & WebRTC

### 5.1 Room Naming

- Room name used by y-webrtc = `board:${boardId}`
- All peers joining `/board/:boardId` connect to that room.

### 5.2 Connection Lifecycle (using y-webrtc)

1. On app start, parse `boardId` from URL.
2. Create `Y.Doc` and initialize default structure if new.
3. Create `WebrtcProvider` from `y-webrtc`:
    ```ts
    const provider = new WebrtcProvider(`board:${boardId}`, yDoc, {
        signaling: [
            "wss://signaling.yjs.dev",
            "wss://y-webrtc-signaling-eu.herokuapp.com",
            // configurable list
        ],
        password: undefined, // optional later
    });
    ```
4. `provider.awareness` is used for basic presence (participant count, optional cursors).
5. When another peer opens same `boardId`, provider:
    - Uses signaling servers to discover existing peers.
    - Negotiates WebRTC DataChannels.
    - Syncs Y.Doc state automatically (full sync + incremental updates).

### 5.3 Robustness

- Y.js handles:
    - Partial connectivity (not all peers must be connected to all others).
    - Late joiners get full state from any connected peer.
    - Concurrent edits → eventual consistency via CRDT.

- If **all peers leave**:
    - Room disappears.
    - The next peer to open `/board/:boardId`:
        - Loads local snapshot if available.
        - Becomes first peer in new room.
        - Subsequent peers sync from them.

---

## 6. Local Persistence

### 6.1 Storage Strategy

- Use IndexedDB via `idb-keyval` or simple wrapper.

Key: `retro-board:${boardId}`

Stored structure:

```ts
interface StoredBoardSnapshot {
    boardId: string;
    lastUpdatedAt: number;
    yDocState: Uint8Array; // Y.js encoded state
}
```

### 6.2 Snapshot Flow

- On Y.Doc update event:
    - Debounce (e.g. 1–2 seconds).
    - `const encoded = Y.encodeStateAsUpdate(doc);`
    - Store `encoded` in IndexedDB under `boardId`.

- On load:
    - Check IndexedDB for snapshot:
        - If found: `Y.applyUpdate(doc, snapshot.yDocState);`
        - Then init y-webrtc provider (it will sync incremental changes).

This ensures:

- Rejoining same board on same browser restores previous state even if no peers are online.
- Data always lives only in browser storage + in-memory; no central DB.

---

## 7. URL Routing & Session Lifecycle

### 7.1 Routes

- `/`:
    - Generate new `boardId` (e.g., `uuid v4` or short hash).
    - `window.location.replace('/board/' + boardId)`

- `/board/:boardId`:
    - Initialize board for that ID:
        - Create Y.Doc.
        - Load snapshot if exists.
        - If no snapshot and doc is empty: create default columns (Good/Bad/Start/Stop) implicitly via UI; notes list empty.
        - Attach y-webrtc provider.

### 7.2 Session Rules

- Board is “alive” as long as at least one browser has that `boardId` open.
- If all browsers close:
    - The “live” room is gone; only local snapshots remain per browser.
- A new user opening the URL later:
    - If no other peers are online:
        - They either see:
            - Empty board (if no snapshot for them), or
            - Their local snapshot (if they previously visited).
    - If some peers are online:
        - They get full state from them via y-webrtc.

---

## 8. UI Components (Lit)

### 8.1 Component Tree

- `<app-root>`
    - Handles routing (`/` vs `/board/:id`)
    - Creates Y.Doc and Provider for board route
    - Provides board state to children (via context or simple state store)

- `<retro-board>`
    - Props: `doc: Y.Doc`
    - Renders 4 columns
    - Handles double-click to create note
    - Subscribes to Y.Doc changes to re-render

- `<retro-column>`
    - Props: `columnId: ColumnId`
    - Filters notes by `columnId`
    - Handles note layout (x/y within column)

- `<sticky-note>`
    - Props: `note: Note`
    - Inline editing (input/textarea)
    - Drag behavior (pointer events)

- `<presence-indicator>`
    - Uses `provider.awareness` to show participant count

### 8.2 Note Creation & Editing Flows

- **Create note:**
    - Double-click in column area:
        - Compute initial `x`, `y` within column.
        - Y.js update:
            ```ts
            const noteId = uuid();
            notesMap.set(noteId, {
                id: noteId,
                columnId,
                text: "",
                x,
                y,
                createdAt: Date.now(),
                updatedAt: Date.now(),
            });
            ```
        - CRDT sync ensures other peers see the note.

- **Update note text:**
    - On blur or Enter:
        - Replace `text` + `updatedAt` in Y.Map entry.

- **Drag note:**
    - On drag end:
        - Update `x`, `y` and possibly `columnId` in Y.Doc.

- **Delete note:**
    - Click X:
        - `notesMap.delete(noteId);`

All these changes are ops in Y.js; they sync automatically over WebRTC.

---

## 9. Build & Deploy (Vite + GitHub Pages)

### 9.1 Vite Setup

- `vite.config.ts`:
    - Set base to repo name for GitHub Pages:
        ```ts
        export default defineConfig({
            base: "/<repo-name>/",
            plugins: [litPlugin()], // if using a lit plugin, optional
        });
        ```

- Entry point: `src/main.ts`
    - `customElements.define('app-root', AppRoot);`
    - Mount `<app-root>` in `index.html`.

### 9.2 GitHub Pages Workflow

- Github Action `.github/workflows/deploy.yml` example:
    - On push to `main`:
        - `npm ci`
        - `npm run build`
        - Deploy `dist/` to `gh-pages` branch.

---

## 10. Error Handling & Edge Cases

- **No peers & no local snapshot:**
    - Show empty board.
- **Signaling servers unreachable:**
    - App still works single-player; no real-time sync.
    - Show small warning badge: “Offline collaboration; changes stay local.”
- **WebRTC failures (firewall / restrictive NAT):**
    - Same as above; degrade to local-only mode.
- **Version changes / breaking updates:**
    - Embed schema version in stored snapshot.
    - On mismatch, either:
        - Migrate, or
        - Drop snapshot and start fresh (for MVP, likely drop).

---

## 11. Open Decisions / Options

1. **Library or custom sync?**
    - Spec assumes Y.js + y-webrtc for robustness.
    - If you want a custom protocol on raw WebRTC DataChannels, we’d need:
        - Signaling mechanism (still required).
        - Custom op-log, conflict resolution, reconnection logic.

2. **Security / privacy:**
    - Optional future: add “room password” tied into y-webrtc.

3. **Retention in browser:**
    - Define max size / time for snapshots; maybe purge older boards.

---

If you’d like, next step I can outline the concrete file structure (e.g., `src/state/board.ts`, `src/components/retro-board.ts`, etc.) plus a minimal first-pass pseudo-implementation for the Lit components and the Y.js wiring.
